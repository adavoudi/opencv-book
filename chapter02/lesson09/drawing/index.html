<!DOCTYPE html>
<html lang="Farsi">
<head>

<title>پردازش تصویر در OpenCV | مولد عدد تصادفی و ترسیم متن</title>

<meta charset="utf-8">
<meta name="description" content="">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:type" content="website">
<meta property="og:title" content="">
<meta property="og:url" content="https://adavoudi.github.io/opencv-book">
<meta property="og:site_name" content="پردازش تصویر در OpenCV">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="">
<meta name="twitter:description" content="">

<link rel="short icon" href="/static/img/mira.png">
<link href="/opencv-book/static/node_modules/bulma-rtl/css/bulma-rtl.css" rel="stylesheet">
<link href="/opencv-book/static/zero60/style.css" rel="stylesheet">
<link href="/opencv-book/static/zero60/agate.css" rel="stylesheet">

<link href="https://cdn.jsdelivr.net/gh/rastikerdar/sahel-font@v2.0.2/dist/font-face.css" rel="stylesheet" type="text/css" />
 
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.9.0/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/katex@0.9.0/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.9.0/dist/contrib/auto-render.min.js"></script>

</head>
<body>

  <header class="hero is-info columns">
    <div class="hero-body">
        <div class="container">
            <h1 class="title">
              <a href="/opencv-book">
                پردازش تصویر در OpenCV
              </a>
            </h1>
            <h2 class="subtitle"></h2>
        </div>
    </div>
    <span class="sidebar_toggle">
        <em class="open-icon"></em>
    </span>
</header>

  <section class="main-content columns is-fullheight">
    <aside id="sidebar" class="column is-one-quarter-desktop is-one-third-tablet section ">
  <div class="sidebar__inner">
    <ul class="menu-list">
        
        <li>
        
        
          <span class="season">فصل اول - معرفی</span>
          <ul>
        
            <li>
              <a href="/opencv-book/chapter01/lesson01/ocv-intro/">- معرفی اُ سی وی</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter01/lesson02/load-show-save/">- بارگذاری، نمایش و ذخیره تصویر</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter01/lesson03/mat-class/">- کلاس MAT</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter01/lesson04/store-retrieve/">- ذخیره سازی و بازیابی اطلاعات</a>
            </li>
        
        </ul>
        </li>
        
        <li>
        
        
          <span class="season">فصل دوم - حوزهٔ مکان</span>
          <ul>
        
            <li>
              <a href="/opencv-book/chapter02/lesson01/simple-shapes/">- شکل‌های هندسی ساده</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter02/lesson02/linear-blend/">- ترکیب خطی دو تصویر</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter02/lesson03/linear-filter/">- فیلتر خطی</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter02/lesson04/affine-transformation/">- تبدیل اَفاین</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter02/lesson05/map/">- نگاشت</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter02/lesson06/contrast-brightness/">- تغییر کنتراست و روشنایی تصویر</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter02/lesson07/smoothing/">- هموار سازی تصویر</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter02/lesson08/border/">- اضافه کردن قاب به تصویر</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter02/lesson09/drawing/">- مولد عدد تصادفی و ترسیم متن</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter02/lesson10/zooming/">- بزرگ‌نمایی و کوچک‌نمایی تصویر</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter02/lesson11/threshold/">- آستانه‌گذاری</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter02/lesson12/image-histogram/">- بافت‌نگار تصویر</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter02/lesson13/equalize-histogram/">- برابرسازی بافت‌نگار</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter02/lesson14/sobel-operator/">- عملگر سابل</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter02/lesson15/laplace-operator/">- عملگر لاپلاس</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter02/lesson16/canny-operator/">- عملگر کَنی</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter02/lesson17/contours/">- کانتورهای تصویر</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter02/lesson18/convex-hull/">- پوش محدب</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter02/lesson19/contours-frames/">- قاب‌های مستطیلی و دایره‌ای برای کانتورها</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter02/lesson20/contours-rotated-frames/">- قاب‌های چرخیدهٔ مستطیلی و بیضوی برای کانتورها</a>
            </li>
        
        </ul>
        </li>
        
        <li>
        
        
          <span class="season">فصل سوم - حوزهٔ زمان</span>
          <ul>
        
            <li>
              <a href="/opencv-book/chapter03/lesson01/discrete-fourier/">- تبدیل فوریهٔ گسسته</a>
            </li>
        
        </ul>
        </li>
        
        <li>
        
        
          <span class="season">فصل چهارم - مورفولوژی</span>
          <ul>
        
            <li>
              <a href="/opencv-book/chapter04/lesson01/erode-dilate/">- فرسایش و گشایش</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter04/lesson02/morphology-transformations/">- تبدیل‌های مورفولوژی پیچیده</a>
            </li>
        
        </ul>
        </li>
        
        <li>
        
        
          <span class="season">فصل پنجم - شناسایی الگو</span>
          <ul>
        
            <li>
              <a href="/opencv-book/chapter05/lesson01/compare-histograms/">- مقایسه بافت‌نگارها</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter05/lesson02/back-projection/">- بَک پروجکشن</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter05/lesson03/pattern-matching/">- تطبیق الگو</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter05/lesson04/hough-line-transform/">- تبدیل خط هاف</a>
            </li>
        
        
            <li>
              <a href="/opencv-book/chapter05/lesson05/hough-circle-transform/">- تبدیل دایره هاف</a>
            </li>
        
        </ul>
        </li>
        
    </ul>
  </div>
</aside>

    <div class="container column">
        <div class="section" id="content">

  
      
          <h1 class="list">فصل دوم - حوزهٔ مکان</h1>
      

    <h3 class="list">مولد عدد تصادفی و ترسیم متن</h3>

    <div class="content-body content">
    <a name="more"></a>
<p>در بخش <strong><em>شکل‌های هندسی ساده</em></strong>، با دادن پارامترهایی مثل مختصات، رنگ، نازکی و... به توابع هندسی، شکل‌های متفاوتی کشیدیم. در آنجا مقادیر ثابتی را به عنوان پارامتر به آن توابع ارسال می‌کردیم. در این بخش می‌خواهیم از مقادیر تصادفی برای آن پارامترها استفاده کنیم و همچنین عکس مورد نظرمان را با تعداد زیادی شکل هندسی پر کنیم.</p>

<p>برای تولید اعداد تصادفی از کلاس RNG استفاده خواهیم کرد.</p>

<h2 id="کد">کد</h2>

<pre><code class="language-c++">#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;

using namespace cv;

/// Global Variables
const int NUMBER = 100;
const int DELAY = 5;

const int window_width = 900;
const int window_height = 600;
int x_1 = -window_width/2;
int x_2 = window_width*3/2;
int y_1 = -window_width/2;
int y_2 = window_width*3/2;

/// Function headers
static Scalar randomColor( RNG&amp; rng );
int Drawing_Random_Lines( Mat image, char* window_name, RNG rng );
int Drawing_Random_Rectangles( Mat image, char* window_name, RNG rng );
int Drawing_Random_Ellipses( Mat image, char* window_name, RNG rng );
int Drawing_Random_Polylines( Mat image, char* window_name, RNG rng );
int Drawing_Random_Filled_Polygons( Mat image, char* window_name, RNG rng );
int Drawing_Random_Circles( Mat image, char* window_name, RNG rng );
int Displaying_Random_Text( Mat image, char* window_name, RNG rng );
int Displaying_Big_End( Mat image, char* window_name, RNG rng );


/**
 * @function main
 */
int main( void )
{
  int c;

  /// Start creating a window
  char window_name[] = "Drawing_2 Tutorial";

  /// Also create a random object (RNG)
  RNG rng( 0xFFFFFFFF );

  /// Initialize a matrix filled with zeros
  Mat image = Mat::zeros( window_height, window_width, CV_8UC3 );
  /// Show it in a window during DELAY ms
  imshow( window_name, image );
  waitKey( DELAY );

  /// Now, let's draw some lines
  c = Drawing_Random_Lines(image, window_name, rng);
  if( c != 0 ) return 0;

  /// Go on drawing, this time nice rectangles
  c = Drawing_Random_Rectangles(image, window_name, rng);
  if( c != 0 ) return 0;

  /// Draw some ellipses
  c = Drawing_Random_Ellipses( image, window_name, rng );
  if( c != 0 ) return 0;

  /// Now some polylines
  c = Drawing_Random_Polylines( image, window_name, rng );
  if( c != 0 ) return 0;

  /// Draw filled polygons
  c = Drawing_Random_Filled_Polygons( image, window_name, rng );
  if( c != 0 ) return 0;

  /// Draw circles
  c = Drawing_Random_Circles( image, window_name, rng );
  if( c != 0 ) return 0;

  /// Display text in random positions
  c = Displaying_Random_Text( image, window_name, rng );
  if( c != 0 ) return 0;

  /// Displaying the big end!
  c = Displaying_Big_End( image, window_name, rng );
  if( c != 0 ) return 0;

  waitKey(0);
  return 0;
}

/// Function definitions

/**
 * @function randomColor
 * @brief Produces a random color given a random object
 */
static Scalar randomColor( RNG&amp; rng )
{
  int icolor = (unsigned) rng;
  return Scalar( icolor&amp;255, (icolor&gt;&gt;8)&amp;255, (icolor&gt;&gt;16)&amp;255 );
}


/**
 * @function Drawing_Random_Lines
 */
int Drawing_Random_Lines( Mat image, char* window_name, RNG rng )
{
  Point pt1, pt2;

  for( int i = 0; i &lt; NUMBER; i++ )
  {
    pt1.x = rng.uniform( x_1, x_2 );
    pt1.y = rng.uniform( y_1, y_2 );
    pt2.x = rng.uniform( x_1, x_2 );
    pt2.y = rng.uniform( y_1, y_2 );

    line( image, pt1, pt2, randomColor(rng), rng.uniform(1, 10), 8 );
    imshow( window_name, image );
    if( waitKey( DELAY ) &gt;= 0 )
      { return -1; }
  }

  return 0;
}

/**
 * @function Drawing_Rectangles
 */
int Drawing_Random_Rectangles( Mat image, char* window_name, RNG rng )
{
  Point pt1, pt2;
  int lineType = 8;
  int thickness = rng.uniform( -3, 10 );

  for( int i = 0; i &lt; NUMBER; i++ )
  {
    pt1.x = rng.uniform( x_1, x_2 );
    pt1.y = rng.uniform( y_1, y_2 );
    pt2.x = rng.uniform( x_1, x_2 );
    pt2.y = rng.uniform( y_1, y_2 );

    rectangle( image, pt1, pt2, randomColor(rng), MAX( thickness, -1 ), lineType );

    imshow( window_name, image );
    if( waitKey( DELAY ) &gt;= 0 )
      { return -1; }
  }

  return 0;
}

/**
 * @function Drawing_Random_Ellipses
 */
int Drawing_Random_Ellipses( Mat image, char* window_name, RNG rng )
{
  int lineType = 8;

  for ( int i = 0; i &lt; NUMBER; i++ )
  {
    Point center;
    center.x = rng.uniform(x_1, x_2);
    center.y = rng.uniform(y_1, y_2);

    Size axes;
    axes.width = rng.uniform(0, 200);
    axes.height = rng.uniform(0, 200);

    double angle = rng.uniform(0, 180);

    ellipse( image, center, axes, angle, angle - 100, angle + 200,
             randomColor(rng), rng.uniform(-1,9), lineType );

    imshow( window_name, image );

    if( waitKey(DELAY) &gt;= 0 )
      { return -1; }
  }

  return 0;
}

/**
 * @function Drawing_Random_Polylines
 */
int Drawing_Random_Polylines( Mat image, char* window_name, RNG rng )
{
  int lineType = 8;

  for( int i = 0; i&lt; NUMBER; i++ )
  {
    Point pt[2][3];
    pt[0][0].x = rng.uniform(x_1, x_2);
    pt[0][0].y = rng.uniform(y_1, y_2);
    pt[0][1].x = rng.uniform(x_1, x_2);
    pt[0][1].y = rng.uniform(y_1, y_2);
    pt[0][2].x = rng.uniform(x_1, x_2);
    pt[0][2].y = rng.uniform(y_1, y_2);
    pt[1][0].x = rng.uniform(x_1, x_2);
    pt[1][0].y = rng.uniform(y_1, y_2);
    pt[1][1].x = rng.uniform(x_1, x_2);
    pt[1][1].y = rng.uniform(y_1, y_2);
    pt[1][2].x = rng.uniform(x_1, x_2);
    pt[1][2].y = rng.uniform(y_1, y_2);

    const Point* ppt[2] = {pt[0], pt[1]};
    int npt[] = {3, 3};

    polylines(image, ppt, npt, 2, true, randomColor(rng), rng.uniform(1,10), lineType);

    imshow( window_name, image );
    if( waitKey(DELAY) &gt;= 0 )
      { return -1; }
  }
  return 0;
}

/**
 * @function Drawing_Random_Filled_Polygons
 */
int Drawing_Random_Filled_Polygons( Mat image, char* window_name, RNG rng )
{
  int lineType = 8;

  for ( int i = 0; i &lt; NUMBER; i++ )
  {
    Point pt[2][3];
    pt[0][0].x = rng.uniform(x_1, x_2);
    pt[0][0].y = rng.uniform(y_1, y_2);
    pt[0][1].x = rng.uniform(x_1, x_2);
    pt[0][1].y = rng.uniform(y_1, y_2);
    pt[0][2].x = rng.uniform(x_1, x_2);
    pt[0][2].y = rng.uniform(y_1, y_2);
    pt[1][0].x = rng.uniform(x_1, x_2);
    pt[1][0].y = rng.uniform(y_1, y_2);
    pt[1][1].x = rng.uniform(x_1, x_2);
    pt[1][1].y = rng.uniform(y_1, y_2);
    pt[1][2].x = rng.uniform(x_1, x_2);
    pt[1][2].y = rng.uniform(y_1, y_2);

    const Point* ppt[2] = {pt[0], pt[1]};
    int npt[] = {3, 3};

    fillPoly( image, ppt, npt, 2, randomColor(rng), lineType );

    imshow( window_name, image );
    if( waitKey(DELAY) &gt;= 0 )
       { return -1; }
  }
  return 0;
}

/**
 * @function Drawing_Random_Circles
 */
int Drawing_Random_Circles( Mat image, char* window_name, RNG rng )
{
  int lineType = 8;

  for (int i = 0; i &lt; NUMBER; i++)
  {
    Point center;
    center.x = rng.uniform(x_1, x_2);
    center.y = rng.uniform(y_1, y_2);

    circle( image, center, rng.uniform(0, 300), randomColor(rng),
            rng.uniform(-1, 9), lineType );

    imshow( window_name, image );
    if( waitKey(DELAY) &gt;= 0 )
      { return -1; }
  }

  return 0;
}

/**
 * @function Displaying_Random_Text
 */
int Displaying_Random_Text( Mat image, char* window_name, RNG rng )
{
  int lineType = 8;

  for ( int i = 1; i &lt; NUMBER; i++ )
  {
    Point org;
    org.x = rng.uniform(x_1, x_2);
    org.y = rng.uniform(y_1, y_2);

    putText( image, "Testing text rendering", org, rng.uniform(0,8),
             rng.uniform(0,100)*0.05+0.1, randomColor(rng), rng.uniform(1, 10), lineType);

    imshow( window_name, image );
    if( waitKey(DELAY) &gt;= 0 )
      { return -1; }
  }

  return 0;
}

/**
 * @function Displaying_Big_End
 */
int Displaying_Big_End( Mat image, char* window_name, RNG )
{
  Size textsize = getTextSize("OpenCV forever!", FONT_HERSHEY_COMPLEX, 3, 5, 0);
  Point org((window_width - textsize.width)/2, (window_height - textsize.height)/2);
  int lineType = 8;

  Mat image2;

  for( int i = 0; i &lt; 255; i += 2 )
  {
    image2 = image - Scalar::all(i);
    putText( image2, "OpenCV forever!", org, FONT_HERSHEY_COMPLEX, 3,
             Scalar(i, i, 255), 5, lineType );

    imshow( window_name, image2 );
    if( waitKey(DELAY) &gt;= 0 )
       { return -1; }
  }

  return 0;
}
</code></pre>

<h2 id="توضیح">توضیح</h2>

<p>از تابع main شروع می‌کنیم. اولین کاری که در این تابع انجام داده‌ایم، ساخت یک شیء RNG است (خط 42). کلاس RNG یک سازندهٔ عدد تصادفی است. در این مثال rng یک شیء از نوع RNG است که با 0xFFFFFFFF مقداردهی اولیه شده است.</p>

<p>سپس یک ماتریس با مقدار اولیهٔ صفر (که یعنی به رنگ سیاه است) و با طول، عرض و نوع CV_8UC3 درست می‌کنیم (خط 45).</p>

<p>در ادامه شکل‌های تصادفی را رسم می‌کنیم. اگر به خطوط 51 تا 80 نگاه کنید خواهید دید که این خطوط به هشت قسمت، که در واقع هشت تابع هستند، تقسیم شده‌اند. پیاده سازی این توابع تقریباً یکسان است، پس فقط سه تا از این توابع را بررسی می‌کنیم:</p>

<ul>
<li><p><strong>تابع Drawing_Random_Lines</strong></p>

<p>در این تابع:</p>

<ul>
<li><p>حلقهٔ for (خطوط 106 تا 114) به تعداد NUMBER تکرار می‌شود. از آنجایی که تابع line در این حلقه قرار دارد، پس یعنی به تعداد NUMBER، خط رسم خواهد شد.</p></li>
<li><p>دو سَرِ خط با نقاط pt1 و pt2 مشخص می‌شوند. مثلاً pt1 به شکل زیر مقدار دهی می‌شود:</p>

<pre><code class="language-c++">pt1.x = rng.uniform( x_1, x_2 );
pt1.y = rng.uniform( y_1, y_2 );
</code></pre></li>
<li><p>می دانیم که rng یک شیء RNG است. در کد بالا تابع <code>rng.uniform(a,b)</code> را صدا می‌زنیم. این تابع یک عدد تصادفی با توزیع یکنواخت بین مقادیر a و b تولید می‌کند (شامل a و فاقد b).</p></li>
<li><p>از توضیحات بالا متوجه می‌شویم که رأس‌های pt1 و pt2 کاملاً تصادفی خواهند بود؛ پس موقعیت خط‌ها غیر قابل پیش بینی می‌شود و این یک جلوهٔ بصری زیبا تولید می‌کند.</p></li>
<li><p>توجه کنیدکه در تابع line به جای رنگ، تابع <code>randomColor(rng)</code> را قرار داده‌ایم. این تابع به شکل زیر پیاده سازی شده است:</p>

<pre><code class="language-c++">static Scalar randomColor( RNG&amp; rng )
{
int icolor = (unsigned) rng;
return Scalar( icolor&amp;255, (icolor&gt;&gt;8)&amp;255, (icolor&gt;&gt;16)&amp;255 );
}
</code></pre>

<p>همان طور که می‌بینید، خروجی این تابع یک Scalar است که با سه مقدار تصادفی پر شده و این سه مقدار نشان دهندهٔ R، G و B هستند. پس رنگ خط‌ها هم تصادفی خواهد بود!</p></li>
</ul>

<p>توضیحات بالا برای توابع دیگر که دایره، مستطیل، چند ضلعی و... تولید می‌کنند یکسان است. فقط پارامترهای دیگر مثل مرکز دایره یا بیضی و رأس‌های مستطیل و چند ضلعی نیز تصادفی خواهند بود.</p></li>
<li><p><strong>تابع Display_Random_Text</strong></p>

<p>در این تابع همه چیز آشنا به نظر می‌رسد، اما عبارت زیر جدید است:</p>

<pre><code class="language-c++">putText( image, "Testing text rendering", org, rng.uniform(0,8),
        rng.uniform(0,100)*0.05+0.1, randomColor(rng),
        rng.uniform(1, 10), lineType );
</code></pre>

<p>این تابع چه کاری انجام می‌دهد؟! در مورد این مثال:</p>

<ul>
<li>متن "Testing text rendering" را روی عکس image رسم می‌کند.</li>
<li>گوشهٔ پایین و چپ متن در نقطهٔ org قرار دارد.</li>
<li>نوع فونت، یک عدد تصادفی در بازهٔ 0 تا 8 است.</li>
<li>مقیاس فونت با عبارت <code>rng.uniform(0, 100) * 0.05 + 0.1</code> که یک عدد تصادفی بین 0.1 تا 5.1 است، مشخص شده.</li>
<li>رنگ متن تصادفی است (با تابع <code>randomColor(rng)</code> به دست می‌آید).</li>
<li><p>ضخامت متن بین 0 تا 10 است که با تابع <code>rng.uniform(1, 10)</code> مشخص می‌شود.</p>

<p>در نتیجه به تعداد NUMBER، متن روی عکسمان خواهیم داشت که در مکان‌های تصادفی قرار گرفته‌اند.</p></li>
</ul></li>
<li><p><strong>تابع Display_Big_End</strong></p>

<p>به جز تابع getTextSize (که اندازهٔ متن داده شده را بر می‌گرداند)، تنها قطعه کد زیر جدید است:</p>

<pre><code class="language-c++">image2 = image - Scalar::all(i);
</code></pre>

<p>یعنی image2 برابر است با تفریق <code>Scalar::all(i)</code> از image. در حقیقت مقدار هر پیکسل image2 برابر است با تفریق مقدار i از image (به یاد داشته باشید که هر پیکسل متشکل از سه مقدار R، G و B است، پس این عمل روی همهٔ آنها تأثیر می‌گذارد).</p>

<p>همچنین به یاد داشته باشید که عمل تفریق خودش به صورت خودکار عمل saturate_cast را انجام می‌دهد تا همیشه مقادیر معتبر (که در این مثال بین 0 تا 255 است) را تولید کند.</p></li>
</ul>

<h2 id="خروجی">خروجی</h2>

<p>روند اجرای برنامه به صورت زیر است:</p>

<ol>
<li><p>ابتدا به تعداد NUMBER خط تصادفی روی صفحه نشان داده می‌شود:</p>

<p><img src="/opencv-book/media/image45.png" alt="mage4" id="mage4"></p></li>
<li><p>سپس تعدادی مستطیل تصادفی نشان داده می‌شود.</p></li>
<li><p>حالا تعدادی بیضی با مختصات، اندازه، نازکی و اندازهٔ قوس تصادفی کشیده می‌شود.</p>

<p><img src="/opencv-book/media/image46.png" alt="mage4" id="mage4"></p></li>
<li><p>بعد تعدادی چند ضلعی تو خالی کشیده می‌شود:</p>

<p><img src="/opencv-book/media/image47.png" alt="mage4" id="mage4"></p></li>
<li><p>سپس چند ضلعی‌های توپُر.</p></li>
<li><p>و آخرین شکل هندسی، دایره:</p>

<p><img src="/opencv-book/media/image48.png" alt="mage4" id="mage4"></p></li>
<li><p>بعد از آن، متن "Testing text rendering" چندین بار با فونت، اندازه، رنگ و مختصات متفاوت نشان داده می‌شود.</p></li>
<li><p>در نهایت عبارت OpenCV For Ever روی تصویر به تنهایی نمایش داده می‌شود.</p>

<p><img src="/opencv-book/media/image49.png" alt="mage4" id="mage4"></p>

<p>​</p></li>
</ol>
    </div>
  


</div>

<div class="section">
    <nav class="pagination" role="navigation" aria-label="pagination">
    <a href="/opencv-book/chapter02/lesson08/border/" class="pagination-previous button is-primary is-outlined">
    →
    اضافه کردن قاب به تصویر
  </a>




  <a href="/opencv-book/chapter02/lesson10/zooming/" class="pagination-next button is-primary is-outlined">
    بزرگ‌نمایی و کوچک‌نمایی تصویر
    ←
  </a>
    </nav>
</div>
    </div>

  </section>

  <footer class="columns hero section is-dark has-text-centered">
        <div class="container ">
            <div class="columns">

                <div class="column">
                    <div class="footer-header">
                       به این جاها سر بزنید
                    </div>
                    <ul class="related-links has-text-centered">
                        <li>
                            <a href="/opencv-book/pdf/opencv-book-v1.pdf" target="_blank">دریافت کتاب با فرمت پی‌دی‌اف</a>
                        </li>
                        <li>
                            <a href="https://github.com/adavoudi/opencv-book/issues" target="_blank">گزارش مشکلات</a>
                        </li>
                    </ul>
                </div>
                <div class="column">
                    <div class="footer-header">
                    پردازش تصویر در OpenCV
                    </div>
                    <div class="socials">
                      <a href="/opencv-book">
                        <img class="cover" src="/opencv-book/media/cover-small.jpg">
                      </a>
                    </div>
                </div>


                </div>
            </div>
            <div class="has-text-centered credit">
              <div>
                ارائه شده بر بستر
                <a href="https://miraxy.github.io/" target="_blank">«میرا»</a>
                و قالب از
                <a href="https://dutymess.github.io/laravel-0-to-60/" target="_blank">
                «لاراول، از صفر تا شصت»
              </a>                
              </div>
            </div>
        </div>
    </footer>


    
<script type="text/javascript" src="/opencv-book/static/js/jquery.min.js"></script>
<script src="/opencv-book/static/js/highlight.pack.js"></script>
<script src="/opencv-book/static/js/highlightjs-line-numbers.min.js"></script>
<script src="/opencv-book/static/js/app.js"></script>

<script>
    renderMathInElement(document.body,{ delimiters:
      [
       {left: "$$", right: "$$", display: true},
       {left: "$", right: "$", display: false}
      ]
    });
</script>

<script>
    // Trim extra blank line of the codes
    var y = document.querySelectorAll("pre code");
    for(var i = 0; i < y.length; i++) {
      y[i].innerHTML = y[i].innerHTML.trimRight();
    }
</script>

</body>
</html>