---
utid: 1000-01-02
chapter: 01
chaptername: فصل اول - معرفی
part: 02
title: بارگذاری، نمایش و ذخیره تصویر
---

در این بخش می‌خواهیم شما را با سه عمل بنیادی آشنا کنیم. تقریباً در تمام کاربردهای پردازش تصویری به سه عمل بارگذاری، نمایش و ذخیره تصویر نیاز داریم. در ادامه با نحوه انجام این کارها در اُ سی وی آشنا می‌شویم.



## کد

```c++
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>

int main( int argc, char** argv )
{
    char* imageName = argv[1];

    cv::Mat image;
    image = cv::imread( imageName, CV_LOAD_IMAGE_COLOR );

    if(!image.data )
    {
        printf( " No image data \n " );
        return -1;
    }

    cv::Mat gray_image;
    cv::cvtColor( image, gray_image,  CV_BGR2GRAY);

    cv::imwrite( argv[2], gray_image );

    cv::namedWindow( imageName, CV_WINDOW_AUTOSIZE );
    cv::namedWindow( "Gray image", CV_WINDOW_AUTOSIZE );

    cv::imshow( imageName, image );
    cv::imshow( "Gray image", gray_image );

    cv::waitKey(0);

    return 0;
}
```



## توضیح

در خطوط 1 تا 3 فایل‌های سرایند مورد نیاز را وارد برنامه می‌کنیم. فایل سرایند core.hpp مربوط به ماژول Core در اُ سی وی است که توابع و متغیرهای عمومی در آن قرار دارند. کلاس Mat در این ماژول تعریف شده است.

فایل سرایند highgui.hpp هم مربوط به ماژولی با همین نام در اُ سی وی است. در این فایل توابع و کلاس‌های مربوط به رابط گرافیکی اُ سی وی قرار دارد. توابع imread، imshow، imwrite و waitKey در این ماژول تعریف شده‌اند.

فایل سرایند imgproc.hpp مربوط به ماژول imgProc است. در این ماژول توابع و الگوریتم‌های پردازش تصویر قرار گرفته‌اند. تابع cvtColor و پرچم‌های آن در این مازول تعریف شده‌اند.

در خط 7 آدرس تصویر ورودی را از آرگومان ورودی برنامه می‌گیریم و در متغیر imageName قرار می‌دهیم.

در خط 9 یک شیء از کلاس Mat درست می‌کنیم. قرار است تصویر ورودی در این شیء قرار گیرد.

در خط 10 با استفاده از تابع imread تصویر ورودی را می‌خوانیم. این تابع دو آرگومان دارد. آرگومان اول آدرس تصویر است و آرگومان دوم نحوه بارگذاری تصویر است. در اینجا مشخص کرده‌ایم که تصویر به صورت رنگی بارگذاری شود. اگر می‌خواستیم تصویر به صورت سیاه و سفید بارگذاری شود، باید از پرچم CV_LOAD_IMAGE_GRAYSCALE استفاده می‌کردیم.

در خط 12 چک می‌کنیم که آیا تصویر درست بارگذاری شده است یا نه. اگر درست بارگذاری نشده باشد یک پیغام خطا نشان می‌دهیم و از برنامه خارج می‌شویم.

در خط 19 با استفاده از تابع cvtColor فضای رنگی تصویر ورودی را از رنگی به سیاه و سفید می‌بریم. آرگومان اول این تابع تصویر ورودی و آرگومان دوم تصویر خروجی است. آرگومان سوم مشخص می‌کند که از چه فضای رنگی به چه فضای رنگی می‌خواهیم تبدیل کنیم.

در خط 21 با استفاده از تابع imwrite تصویر سیاه و سفید را ذخیره می‌کنیم. آرگومان اول این تابع آدرس تصویر خروجی است و آرگومان دوم هم تصویری است که می‌خواهیم ذخیره کنیم. دقت کنید که پسوند نام تصویر خروجی تعیین می‌کند که تصویر خروجی از چه نوعی باشد. مثلاً اگر نام تصویر خروجی bla.jpg باشد، تصویر خروجی به فرمت jpg نوشته می‌شود.

در خطوط 23 و 24 دو پنجره برای نمایش تصویر ورودی و تصویر خروجی درست می‌کنیم. آرگومان اول این توابع نام پنجره و آرگومان دوم تنظیمات پنجره است.

در خطوط 26 و 27 با استفاده از تابع imshow تصویر ورودی و تصویر خروجی را در پنجره‌هایی که درست کردیم، نمایش می‌دهیم. آرگومان اول این توابع نام پنجره و آرگومان دوم تصویری است که می‌خواهیم نمایش دهیم.

در خط 29 با استفاده از تابع waitKey کاری می‌کنیم که برنامه ما تا زمانی که کاربر کلیدی فشار نداده است همچنان در حال اجرا باشد.



## خروجی

برنامه را به صورت زیر اجرا می‌کنیم:

```powershell
SimpleProgram.exe "D:/input.jpg" "D:/output.jpg"
```

| ![تصویر ورودی](/opencv-book/media/image3.jpg) | ![تصویر خروجی](/opencv-book/media/image4.jpg) |
| :---------------------------------: | :---------------------------------: |
|             تصویر ورودی             |             تصویر خروجی             |

